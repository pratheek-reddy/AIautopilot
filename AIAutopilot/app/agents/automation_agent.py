from typing import Dict, List, Optional, Any
from pydantic import BaseModel
from app.api.models import Script
from openai import OpenAI
import json
import subprocess
import tempfile
import os
from app.core.config import settings

class AutomationAgent:
    def __init__(self):
        self.client = OpenAI(api_key=settings.OPENAI_API_KEY)
        self.model = settings.OPENAI_MODEL

    def run(self, request: Dict[str, Any]) -> Script:
        """Execute automation tasks based on the request."""
        try:
            # Determine script type based on request
            request_text = request['request'].lower()
            shell_keywords = {'shell', 'bash', 'sh', 'command line', 'terminal'}
            script_type = "bash" if any(keyword in request_text for keyword in shell_keywords) else "python"

            # Create a prompt for the LLM
            prompt = f"""Given the following request, create a {script_type} script that accomplishes the task.
            The script should be well-documented and handle errors appropriately.

            Request: {request['request']}

            Return the response in the following JSON format:
            {{
                "script": "string (the {script_type} script)",
                "explanation": "string (brief explanation of how the script works)"
            }}

            Make sure to:
            1. Include proper error handling
            2. Add clear comments
            3. Follow {script_type} best practices
            4. Return ONLY the JSON object, no other text
            """

            # Get response from LLM
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": f"You are an expert {script_type} developer that creates well-documented and robust scripts."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7
            )

            # Extract and parse the response
            content = response.choices[0].message.content.strip()
            
            # Try to find JSON content if there's any surrounding text
            import re
            json_match = re.search(r'\{.*\}', content, re.DOTALL)
            content = json_match.group(0) if json_match else content
            
            try:
                script_json = json.loads(content)
            except json.JSONDecodeError:
                script_json = {
                    "script": content,
                    "explanation": "Script generated by LLM"
                }

            # Validate the response structure
            if not isinstance(script_json, dict) or "script" not in script_json:
                raise ValueError("Invalid response structure")
            
            script_json.setdefault("explanation", "No explanation provided")

            # Validate script syntax
            lint_passed, lint_output = self._validate_syntax(script_json["script"], script_type)

            return Script(
                language=script_type.capitalize(),
                code=script_json["script"],
                lint_passed=lint_passed,
                lint_output=lint_output
            )

        except Exception as e:
            raise

    def _validate_syntax(self, code: str, script_type: str) -> tuple[bool, str]:
        """Validate the syntax of the generated script."""
        try:
            with tempfile.NamedTemporaryFile(mode='w', suffix=f'.{script_type}', delete=False) as f:
                f.write(code)
                temp_file = f.name
            if script_type == "bash":
                result = subprocess.run(['bash', '-n', temp_file], capture_output=True, text=True)
            elif script_type == "python":
                result = subprocess.run(['python', '-m', 'py_compile', temp_file], capture_output=True, text=True)
            else:
                raise ValueError(f"Unsupported script type: {script_type}")
            os.unlink(temp_file)
            return result.returncode == 0, result.stderr
        except Exception as e:
            return False, str(e)
